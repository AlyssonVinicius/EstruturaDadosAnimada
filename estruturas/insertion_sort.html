<p> &nbsp; O Insertion Sort (ou ordenação por inserção) é um algoritmo de ordenação simples e eficaz que funciona de maneira semelhante à maneira como as pessoas classificam cartas em um jogo de cartas. Ele percorre a lista e insere cada elemento na posição correta na parte ordenada da lista à medida que avança. O Insertion Sort é eficaz para listas pequenas ou quase ordenadas, mas pode ser ineficiente para listas grandes devido à sua complexidade de tempo quadrático (O(n^2)) no pior caso. </p>

<br>
<p> <strong> &nbsp;&nbsp; Passos do Insertion Sort:</strong> </p>
<strong> &nbsp;&nbsp;1- Parte Ordenada e Não Ordenada:</strong> O algoritmo começa com o primeiro elemento da lista como a parte ordenada e os demais elementos como a parte não ordenada. <br>
<strong> &nbsp;&nbsp;2- Iteração e Inserção:</strong> A cada iteração, um elemento da parte não ordenada é escolhido. Esse elemento é inserido na posição correta na parte ordenada, deslocando os elementos maiores (ou menores, dependendo da ordem desejada) para abrir espaço. <br>
<strong> &nbsp;&nbsp;3- Continuação:</strong> O processo é repetido até que todos os elementos da parte não ordenada tenham sido inseridos na parte ordenada. <br>

<br>
<p> <strong> &nbsp; Vantagens do Insertion Sort:</strong> </p>
&nbsp; <strong>Simplicidade:</strong> O Insertion Sort é fácil de entender e implementar. Ele se assemelha ao processo de classificar cartas em uma mão. <br>
&nbsp; <strong>Eficiência para Pequenas Listas:</strong> O Insertion Sort tem um desempenho decente para listas pequenas ou quase ordenadas, uma vez que requer um número limitado de comparações e trocas. <br>

<br>
<p> <strong> &nbsp; Desvantagens do Insertion Sort:</strong> </p>
&nbsp; <strong>Ineficiência para Listas Grandes:</strong> A complexidade de tempo do Insertion Sort é O(n^2), tornando-o ineficiente para listas grandes, especialmente quando comparado a algoritmos mais eficientes, como Merge Sort ou Quick Sort. <br>
&nbsp; <strong>Falta de Adaptação:</strong> O desempenho do Insertion Sort não é afetado pela distribuição inicial dos elementos. Ele executa um número fixo de comparações e trocas, independentemente da ordem dos elementos. <br>

<br>
<p> <strong> &nbsp; Ilustração:</strong> </p>
&nbsp; 1- Considere a lista não ordenada [5, 2, 9, 1, 5, 6]: <br>
&nbsp; 2- O primeiro elemento (5) é a parte ordenada. <br>
&nbsp; 3- O segundo elemento (2) é inserido na parte ordenada, resultando em [2, 5]. <br>
&nbsp; 4- O terceiro elemento (9) é inserido na parte ordenada, resultando em [2, 5, 9]. <br>
&nbsp; 5- O quarto elemento (1) é inserido na parte ordenada, resultando em [1, 2, 5, 9]. <br>
&nbsp; 6- O quinto elemento (5) é inserido na parte ordenada, resultando em [1, 2, 5, 5, 9]. <br>
&nbsp; 7- O sexto elemento (6) é inserido na parte ordenada, resultando em [1, 2, 5, 5, 6, 9]. <br>
&nbsp; 8- A lista agora está ordenada. <br>

<br>
<p> &nbsp; Em resumo, o Insertion Sort é um algoritmo de ordenação simples que é eficaz para listas pequenas ou quase ordenadas, mas é ineficiente para listas grandes devido à sua complexidade de tempo quadrático. </p>

<br>
<p>
    &nbsp; Código em <strong>C</strong>:
    <a class="links" href="https://gist.githubusercontent.com/divanibarbosa/a863039c1f76d19c199eb0d18d40c30e/raw/066836da5a6e3bb23c9c4745823aedbe5a502e9d/VetorInsertionSort.c">clique aqui</a>
</p>